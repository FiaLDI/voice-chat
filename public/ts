<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-User WebRTC Voice Chat</title>
    <style>
        body {
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    margin: 0;
    padding: 20px;
    text-align: center;
}

.container {
    display: flex;
    max-width: 660px;
    margin: 0 auto;
    flex-direction: column;
}

.container * {
    display: block;
}

h1 {
    color: #333;
}

#controls {
    display: flex;
    gap: 1em;
    flex-wrap: wrap;
    max-width: 660px;
    justify-content: space-around;
    width: 100%;
}

button {
    width: 100%;
    flex-basis: 90px;
    font-size: 16px;
    height: 45.4px;
    cursor: pointer;
    border: none;
    border-radius: 5px;
    background-color: #007BFF;
    color: white;
}

button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

#remoteAudios {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
}

#remoteAudios {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.audio-container {
    margin: 10px 0;
    display: none;
    align-items: center;
}

audio {
    margin-right: 10px;
}

.username {
    font-weight: bold;
    margin-right: 10px;
    color: #555;
}

ul {
    list-style: none;
    padding: 0;
}
.mic-activity {
    width: 20px;
    height: 20px;
    background-color: lightgray;
    border-radius: 50%;
    transition: transform 0.1s ease-in-out, background-color 0.1s ease-in-out;
    margin-left: 10px;
}

#usernameInput {
    padding: 0.3em;
    width: 400px;
    font-size: 24px;
    border-radius: 5px;
    border: 1px solid #999999;
}

#userList li {
    display: flex;
    justify-content: space-between;
    padding: 1em;
    border-bottom: 1px solid #999;
}
#userList li div:nth-child(1) {
    width: 300px;
    text-align: left;
}

.mic-indicator {
    
    min-width: 20px;
    flex-basis: 20px;
}
    </style>
</head>
<body>
    <h1>Multi-User WebRTC Voice Chat</h1>
    <div class="container">
        <div id="controls">
            <input type="text" id="usernameInput" placeholder="Enter your name" />
            <button id="joinCall">Join Call</button>
            <button id="endCall" disabled>End Call</button>
        </div>
        <ul id="userList"></ul> <!-- Список подключённых пользователей -->
        <div id="remoteAudios"></div> <!-- Контейнер для аудио элементов -->

        </div>
            

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <script>
        const socket = io();
const joinCallButton = document.getElementById('joinCall');
const endCallButton = document.getElementById('endCall');
const remoteAudios = document.getElementById('remoteAudios');
const usernameInput = document.getElementById('usernameInput');
const userList = document.getElementById('userList'); // Элемент списка для пользователей
let localStream;
let peerConnections = {};
let iceCandidatesQueue = {};
let audioContext;
let analyser;
let dataArray;
let roomId = 'default-room';

const configuration = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }
    ]
};
function initAudioAnalyzer(stream) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioContext.createMediaStreamSource(stream);

    analyser = audioContext.createAnalyser();
    analyser.fftSize = 1024;

    const bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);

    source.connect(analyser);

    // Запускаем анализ активности микрофона
    analyzeMicActivity();
}
function analyzeMicActivity() {
    analyser.getByteTimeDomainData(dataArray);

    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) {
        const value = dataArray[i] - 128;
        sum += (value * value);
    }

    const volume = Math.sqrt(sum / dataArray.length);
    const sensitivityMultiplier = 2;

    // Отправляем уровень активности микрофона на сервер
    socket.emit('mic-activity', { volume: volume*sensitivityMultiplier, roomId });

    // Повторяем анализ через небольшой интервал
    requestAnimationFrame(analyzeMicActivity);
}

function removeUserFromRoom(userId) {
    const audioContainer = document.getElementById(`user-${userId}`);
    if (audioContainer) {
        audioContainer.remove();
    }
}
function updateMicActivity(userId, volume) {
    const indicator = document.getElementById(`indicator-${userId}`);
    if (indicator) {
        // Меняем цвет и размер индикатора в зависимости от громкости
        const greenValue = Math.min(255, volume * 2); // Нормируем до 255
        indicator.style.backgroundColor = `rgb(0, ${greenValue}, 0)`;
        indicator.style.transform = `scale(${1 + volume / 200});`; // Увеличиваем размер
    }
}

// Функция для создания RTCPeerConnection
function createPeerConnection(peerId, username) {
    const peerConnection = new RTCPeerConnection(configuration);

    peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            socket.emit('ice-candidate', {
                target: peerId,
                candidate: event.candidate
            });
        }
    };

    peerConnection.ontrack = (event) => {
        // Проверяем, есть ли уже аудио-элемент для данного пользователя
        if (!document.getElementById(`audio-${peerId}`)) {
            const audioContainer = document.createElement('div');
            audioContainer.className = 'audio-container';
            audioContainer.id = `audio-${peerId}`;

            const audioElement = document.createElement('audio');
            audioElement.srcObject = event.streams[0];
            audioElement.autoplay = true;
            audioElement.controls = true;

            const usernameLabel = document.createElement('span');
            usernameLabel.className = 'username';
            usernameLabel.textContent = username;

            audioContainer.appendChild(usernameLabel);
            audioContainer.appendChild(audioElement);
            remoteAudios.appendChild(audioContainer);

            audioElement.addEventListener('ended', () => {
                removeAudioElement(peerId);
            });
        }
    };

    localStream.getTracks().forEach((track) => {
        peerConnection.addTrack(track, localStream);
    });

    return peerConnection;
}

// Функция для удаления аудио элемента
function removeAudioElement(peerId) {
    const audioContainer = document.getElementById(`audio-${peerId}`);
    if (audioContainer) {
        audioContainer.remove();
        console.log(`Removed audio element for user ${peerId}`);
    }
}

// Функция для обработки сохранённых ICE-кандидатов
async function processIceCandidates(peerId) {
    if (iceCandidatesQueue[peerId] && peerConnections[peerId] && peerConnections[peerId].remoteDescription) {
        for (let candidate of iceCandidatesQueue[peerId]) {
            try {
                await peerConnections[peerId].addIceCandidate(candidate);
            } catch (e) {
                console.error('Error adding received ice candidate', e);
            }
        }
        delete iceCandidatesQueue[peerId]; // Очищаем очередь
    }
}

// Функция для обновления списка пользователей
function updateUserList(users) {
    userList.innerHTML = ''; // Очищаем список
    users.forEach(user => {
        const li = document.createElement('li');

        // Создаем индикатор активности
        const name = document.createElement('div');
        name.textContent = user.username;
        const indicator = document.createElement('div');
        indicator.className = 'mic-indicator';
        indicator.id = `indicator-${user.id}`; // Уникальный ID для индикатора
        indicator.style.width = '20px';
        indicator.style.height = '20px';
        indicator.style.borderRadius = '50%';
        indicator.style.backgroundColor = 'gray'; // Начальный цвет
        indicator.style.display = 'inline-block'; // Отображение в одной строке с именем

        // Добавляем индикатор к элементу списка
        li.appendChild(name);
        li.appendChild(indicator)
        userList.appendChild(li);
    });
}

joinCallButton.onclick = async () => {
    const username = usernameInput.value;
    if (!username) {
        alert("Please enter your name.");
        return;
    }

    joinCallButton.disabled = true;
    endCallButton.disabled = false;

    localStream = await navigator.mediaDevices.getUserMedia({
        audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
        }
    });

    initAudioAnalyzer(localStream);

    peerConnections = {};
    iceCandidatesQueue = {};

    socket.emit('join-room', roomId, username);

    socket.on('update-user-list', (users) => {
        updateUserList(users); // Обновляем список пользователей на клиенте
    });

    socket.on('user-connected', async (userId, username) => {
        console.log('User connected:', userId);
        const peerConnection = createPeerConnection(userId, username);
        peerConnections[userId] = peerConnection;

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        socket.emit('offer', {
            target: userId,
            sdp: peerConnection.localDescription
        });
    });

    socket.on('user-disconnected', (userId) => {
        console.log(`User disconnected: ${userId}`);
        removeUserFromRoom(userId);
        if (peerConnections[userId]) {
            peerConnections[userId].close();
            delete peerConnections[userId];
            removeAudioElement(userId); // Удаляем аудио-элемент при отключении пользователя
        }
    });
    socket.on('update-mic-activity', (userId, volume) => {
        updateMicActivity(userId, volume);
    });

    // Запрос на получение списка пользователей
    socket.emit('request-user-list');
};

// Когда сервер отправляет обновленный список пользователей
socket.on('update-user-list', (users) => {
    console.log('Received user list:', users);
    updateUserList(users);
});

endCallButton.onclick = () => {
    joinCallButton.disabled = false;
    endCallButton.disabled = true;

    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }

    // Закрываем все соединения и удаляем аудио-элементы
    for (let peerId in peerConnections) {
        peerConnections[peerId].close();
        delete peerConnections[peerId];
        removeAudioElement(peerId); // Удаляем все аудио-элементы
    }

    socket.emit('leave-room', roomId);

    iceCandidatesQueue = {};

    // Очищаем контейнер от всех аудио-элементов
    remoteAudios.innerHTML = '';

    socket.emit('leave-room', roomId);
};

socket.on('offer', async (data) => {
    const { sdp, sender, username } = data;

    if (!peerConnections[sender]) {
        const peerConnection = createPeerConnection(sender, username);
        peerConnections[sender] = peerConnection;
    }

    const peerConnection = peerConnections[sender];

    try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        socket.emit('answer', {
            target: sender,
            sdp: peerConnection.localDescription
        });

        // Применяем все отложенные ICE-кандидаты
        await processIceCandidates(sender);
    } catch (error) {
        console.error("Error handling offer:", error);
    }
});


socket.on('answer', async (data) => {
    const { sdp, sender } = data;

    if (!peerConnections[sender]) {
        console.error(`Peer connection for ${sender} not found when handling answer.`);
        return;
    }

    const peerConnection = peerConnections[sender];

    try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
        // Применяем все отложенные ICE-кандидаты
        await processIceCandidates(sender);
    } catch (error) {
        console.error("Error handling answer:", error);
    }
});


socket.on('ice-candidate', async (data) => {
    const { candidate, sender } = data;

    if (!peerConnections[sender]) {
        console.error(`Peer connection for ${sender} not found when handling ICE candidate.`);
        return;
    }

    const peerConnection = peerConnections[sender];

    // Создаем RTCIceCandidate, если candidate не пустая строка
    let iceCandidate;
    if (candidate.candidate !== "") {
        iceCandidate = new RTCIceCandidate(candidate);
    } else {
        console.log(`End of candidates for ${sender}`);
        iceCandidate = null; // Обрабатываем это как конец ICE-кандидатов
    }

    // Определяем, используется ли ufrag для сопоставления с медиа-описанием и ICE поколением
    if (candidate.ufrag) {
        console.log(`Processing candidate with ufrag: ${candidate.ufrag}`);
        // Дополнительная логика для обработки ufrag может быть добавлена здесь.
        // Обычно это применяется для того, чтобы идентифицировать правильное медиа-описание и поколение ICE.
    } else {
        console.log("Processing candidate with most recent ICE generation and media description.");
        // Если ufrag не указан, обрабатываем кандидата для последнего ICE поколения и медиа-описания.
    }

    try {
        if (iceCandidate) {
            // Если удаленное описание уже установлено, добавляем кандидата
            if (peerConnection.remoteDescription) {
                await peerConnection.addIceCandidate(iceCandidate);
            } else {
                // Если удаленное описание еще не установлено, сохраняем кандидата
                if (!iceCandidatesQueue[sender]) {
                    iceCandidatesQueue[sender] = [];
                }
                iceCandidatesQueue[sender].push(iceCandidate);
            }
        } else {
            console.log(`No more ICE candidates for ${sender}`);
            // Логика для обработки конца кандидатов (например, "end-of-candidates" сигнал)
            // можно вызвать функцию для завершения ICE кандидатов для конкретного sender
        }
    } catch (e) {
        console.error('Error processing ICE candidate:', e);
    }
});
    </script>
</body>
</html>
